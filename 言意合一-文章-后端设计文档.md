# 言意合一 - 文章系统后端设计文档

## 1. 项目概述

言意合一是一款基于 Flutter 的笔记应用,采用 Notion 风格的富文本编辑器,支持 AI 辅助写作、文章管理、数据同步等功能。

### 1.1 技术栈
- **前端**: Flutter
- **编辑器**: flutter_quill (富文本编辑)
- **状态管理**: Provider
- **本地存储**: SharedPreferences + Local Storage Service

---

## 2. 前端功能分析

### 2.1 文章相关功能清单

| 文件 | 代码位置 | 功能描述 |
|------|---------|---------|
| **main.dart** | lib/main.dart:26-90 | 应用启动入口,初始化核心服务(文章存储、API服务、Provider) |
| **Article Model** | lib/data/models/article.dart:1-191 | 文章数据模型,包含标题、内容、封面、标签、字体等字段 |
| **Article Storage Service** | lib/data/services/article_storage_service.dart:1-173 | 本地存储服务,负责文章的增删改查、持久化 |
| **Article Repository** | lib/data/repositories/article_repository.dart:1-76 | 数据仓储层,封装 API 调用,处理远程数据交互 |
| **Activity Provider** | lib/providers/activity_provider.dart:1-441 | 文章状态管理,处理本地+远程数据同步、缓存策略 |
| **Article Detail Page** | lib/pages/article_detail_page.dart:1-787 | 文章详情页主入口,集成编辑器、工具栏、面板系统 |
| **Article Editor Controller** | lib/pages/article_detail/article_editor_controller.dart:1-249 | 编辑器业务逻辑,防抖保存、变更检测、生命周期管理 |
| **Article AI Panel** | lib/pages/article_detail/article_ai_panel.dart:1-1218 | AI 面板组件,文本分析、智能建议生成、缓存机制 |
| **Article Menu Manager** | lib/pages/article_detail/article_menu_manager.dart | 菜单管理器,处理置顶、删除、封面图、标签等操作 |
| **Article Content** | lib/pages/article_detail/article_content.dart | 富文本编辑器视图,基于 flutter_quill |
| **Article Header** | lib/pages/article_detail/article_header.dart | 文章头部组件,显示标题、日期、阅读时间等元信息 |
| **Article App Bar** | lib/pages/article_detail/article_app_bar.dart | 顶部导航栏,返回按钮、菜单按钮、封面图显示 |
| **Cover Image Manager** | lib/pages/article_detail/cover_image_manager.dart | 封面图管理器,图片选择、缓存、更新 |
| **Article Action Handler** | lib/widgets/article_action_handler.dart | 文章操作处理器,统一处理各种操作事件 |
| **Article List** | lib/widgets/article_list.dart | 文章列表组件,支持按日期分组、置顶排序 |
| **Article Selection Menu** | lib/widgets/article_selection_menu.dart | 文章选择菜单,批量操作支持 |
| **API Service Interface** | lib/data/services/api/api_service_interface.dart:39-63 | API 接口定义,定义所有文章相关的 API 调用 |
| **Mock API Service** | lib/data/services/api/mock_api_service.dart | Mock API 实现,用于开发和测试 |

### 2.2 核心数据模型

#### Article (文章)
```dart
{
  id: String                    // 文章唯一标识
  title: String                 // 标题
  date: DateTime                // 创建日期
  updatedAt: DateTime?          // 更新日期
  content: dynamic              // 内容(Quill Delta JSON 或 String)
  coverImage: String?           // 封面图片 URL
  tags: List<String>            // 标签列表
  isPinned: boolean             // 是否置顶
  pinnedAt: DateTime?           // 置顶时间
  isDeleted: boolean            // 是否已删除(软删除)
  deletedAt: DateTime?          // 删除时间
  hasUpdate: boolean            // 是否有未同步的更新
  fontFamily: String?           // 字体 family
  fontSize: double?             // 字体大小
  fontWeight: int?              // 字体粗细 (0-9)
  lineHeight: double?           // 行高
  letterSpacing: double?        // 字间距
}
```

### 2.3 数据同步策略

当前应用采用 **本地优先 + 异步同步** 的策略:

1. **启动时同步** ([ActivityProvider.dart:53-95](lib/providers/activity_provider.dart#L53-L95))
   - 从本地存储加载数据
   - 从远程服务器获取数据
   - 对比并合并数据(以远程为准)
   - 保存合并后的数据到本地

2. **操作时同步** ([ActivityProvider.dart:149-386](lib/providers/activity_provider.dart#L149-L386))
   - 立即更新本地存储(乐观更新)
   - 更新内存中的文章状态
   - 异步调用 API(后台执行,不阻塞 UI)
   - 失败仅记录日志,不影响用户体验

3. **编辑器防抖** ([article_editor_controller.dart:69-149](lib/pages/article_detail/article_editor_controller.dart#L69-L149))
   - 标题保存: 1秒防抖
   - 内容保存: 2秒防抖
   - 页面离开时立即保存

4. **合并逻辑** ([ActivityProvider.dart:98-138](lib/providers/activity_provider.dart#L98-L138))
   - 服务器删除 → 从本地删除
   - 服务器新增 → 合并到本地
   - 服务器修改 → 以服务器为准(对比 updatedAt)

---

## 3. 后端架构设计

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                         Flutter App                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │   UI Layer   │  │  Provider    │  │  Repository  │       │
│  │  (Pages/     │  │  (Activity   │  │  (Article    │       │
│  │   Widgets)   │──│  Provider)   │──│  Repository) │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ HTTP/REST API
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      Backend API Layer                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  Auth        │  │  Article     │  │  AI          │       │
│  │  Controller  │  │  Controller  │  │  Controller  │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  User        │  │  Activity    │  │  Membership  │       │
│  │  Controller  │  │  Controller  │  │  Controller  │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      Service Layer                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  Article     │  │  AI          │  │  Sync        │       │
│  │  Service     │  │  Service     │  │  Service     │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    Data Access Layer                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  Article     │  │  User        │  │  Activity    │       │
│  │  Repository  │  │  Repository  │  │  Repository  │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      Database Layer                          │
│              PostgreSQL + Redis (Cache)                     │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 技术选型

#### 后端框架
- **语言**: Node.js (TypeScript) 或 Python (FastAPI) 或 Go (Gin)
  - 推荐: **Node.js + NestJS** (与前端同语言,便于全栈开发)
  - 备选: **Python + FastAPI** (AI 生态更好,便于集成 AI 服务)

#### 数据库
- **主数据库**: **PostgreSQL**
  - 理由: 支持复杂查询、JSON 字段、事务、全文搜索
  - 特别适合存储 Quill Delta JSON 格式的内容

- **缓存层**: **Redis**
  - 用途: 热点文章缓存、会话管理、分布式锁、消息队列

- **文件存储**: **对象存储 (OSS)**
  - 本地开发: MinIO
  - 生产环境: 阿里云 OSS / AWS S3 / 腾讯云 COS

#### AI 服务
- **LLM 接入**: OpenAI API / Azure OpenAI / 阿里云通义千问
- **向量数据库** (可选): Pinecone / Milvus / Weaviate (用于语义搜索)

---

## 4. API 设计

### 4.1 通用规范

#### 基础 URL
```
开发环境: http://localhost:3000/api/v1
生产环境: https://api.yanyiheyi.com/api/v1
```

#### 认证方式
```
Authorization: Bearer <access_token>
```

#### 响应格式
```json
{
  "success": true,
  "data": {...},
  "message": "操作成功",
  "timestamp": 1704067200000
}
```

#### 错误响应
```json
{
  "success": false,
  "error": {
    "code": "ARTICLE_NOT_FOUND",
    "message": "文章不存在",
    "details": {...}
  },
  "timestamp": 1704067200000
}
```

### 4.2 文章相关 API

#### 4.2.1 获取文章列表
```http
GET /articles
```

**Query 参数:**
```typescript
{
  page?: number;           // 页码,默认 1
  pageSize?: number;       // 每页数量,默认 20,最大 100
  tags?: string[];         // 标签过滤
  keyword?: string;        // 搜索关键词(标题/内容)
  sortBy?: 'date' | 'updatedAt' | 'pinnedAt';  // 排序字段
  sortOrder?: 'asc' | 'desc';  // 排序方向
  isDeleted?: boolean;     // 是否包含已删除(软删除)
  startDate?: string;      // 开始日期 (ISO 8601)
  endDate?: string;        // 结束日期 (ISO 8601)
}
```

**响应:**
```json
{
  "success": true,
  "data": {
    "articles": [
      {
        "id": "1704067200000",
        "title": "我的第一篇文章",
        "date": "2024-01-01T00:00:00.000Z",
        "updatedAt": "2024-01-01T12:00:00.000Z",
        "content": [{"insert": "文章内容\n"}],
        "coverImage": "https://cdn.example.com/cover.jpg",
        "tags": ["技术", "Flutter"],
        "isPinned": true,
        "pinnedAt": "2024-01-01T10:00:00.000Z",
        "isDeleted": false,
        "deletedAt": null,
        "hasUpdate": false,
        "fontFamily": "Roboto",
        "fontSize": 16,
        "fontWeight": 4,
        "lineHeight": 1.5,
        "letterSpacing": 0.5
      }
    ],
    "pagination": {
      "page": 1,
      "pageSize": 20,
      "total": 100,
      "totalPages": 5
    }
  }
}
```

#### 4.2.2 获取文章详情
```http
GET /articles/:articleId
```

**响应:**
```json
{
  "success": true,
  "data": {
    "article": {
      // 同上面的文章对象
    }
  }
}
```

#### 4.2.3 创建文章
```http
POST /articles
```

**请求体:**
```json
{
  "title": "",
  "content": null,
  "coverImage": null,
  "tags": []
}
```

**响应:**
```json
{
  "success": true,
  "data": {
    "article": {
      "id": "1704067200000",
      "title": "",
      "date": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "content": null,
      ...
    }
  }
}
```

#### 4.2.4 更新文章
```http
PUT /articles/:articleId
```

**请求体:**
```json
{
  "title": "新标题",
  "content": [{"insert": "新内容\n"}],
  "coverImage": "https://cdn.example.com/new-cover.jpg",
  "tags": ["新标签"],
  "fontFamily": "Noto Sans SC",
  "fontSize": 18,
  "fontWeight": 5,
  "lineHeight": 1.8,
  "letterSpacing": 0.3
}
```

**响应:**
```json
{
  "success": true,
  "data": {
    "article": {
      // 更新后的完整文章对象
    }
  }
}
```

#### 4.2.5 删除文章
```http
DELETE /articles/:articleId
```

**响应:**
```json
{
  "success": true,
  "data": null,
  "message": "文章已删除"
}
```

**说明:** 实际执行软删除,设置 `isDeleted=true`, `deletedAt=now()`

#### 4.2.6 置顶/取消置顶文章
```http
PATCH /articles/:articleId/pin
```

**请求体:**
```json
{
  "isPinned": true
}
```

**响应:**
```json
{
  "success": true,
  "data": {
    "article": {
      "id": "1704067200000",
      "isPinned": true,
      "pinnedAt": "2024-01-01T10:00:00.000Z",
      ...
    }
  }
}
```

#### 4.2.7 批量操作文章
```http
POST /articles/batch
```

**请求体:**
```json
{
  "action": "delete" | "pin" | "unpin" | "addTags" | "removeTags",
  "articleIds": ["1704067200000", "1704067200001"],
  "tags": ["标签1", "标签2"]  // 仅 addTags/removeTags 需要
}
```

**响应:**
```json
{
  "success": true,
  "data": {
    "successCount": 2,
    "failedCount": 0,
    "errors": []
  }
}
```

#### 4.2.8 上传封面图
```http
POST /articles/:articleId/cover
```

**请求体:** `multipart/form-data`
```
file: <binary>
```

**响应:**
```json
{
  "success": true,
  "data": {
    "url": "https://cdn.example.com/covers/1704067200000.jpg"
  }
}
```

#### 4.2.9 获取活动数据
```http
GET /activity
```

**Query 参数:**
```typescript
{
  days?: number;  // 获取最近多少天的数据,默认 365
}
```

**响应:**
```json
{
  "success": true,
  "data": {
    "activities": [
      {
        "dateTime": "2024-01-01T00:00:00.000Z",
        "count": 5
      }
    ]
  }
}
```

### 4.3 AI 相关 API

#### 4.3.1 生成 AI 建议
```http
POST /ai/suggest
```

**请求体:**
```json
{
  "type": "expand" | "polish" | "summarize",
  "content": "原文内容",
  "context": "上下文内容(可选)",
  "articleId": "1704067200000"
}
```

**响应 (流式):**
```
data: {"token":"这"}
data: {"token":"是"}
data: {"token":" AI"}
data: {"done":true,"fullText":"这是 AI 的扩写建议..."}
```

**说明:**
- 使用 Server-Sent Events (SSE) 实现流式输出
- 支持打字机效果

#### 4.3.2 刷新 AI 建议
```http
POST /ai/suggest/refresh
```

**请求体:**
```json
{
  "suggestionId": "uuid",
  "type": "expand"
}
```

**响应:** 同上 (流式)

### 4.4 认证相关 API (参考)

#### 4.4.1 微信登录
```http
POST /auth/wechat
```

**请求体:**
```json
{
  "code": "微信授权码"
}
```

**响应:**
```json
{
  "success": true,
  "data": {
    "accessToken": "xxx",
    "refreshToken": "yyy",
    "user": {
      "id": "user_123",
      "nickname": "用户昵称",
      "avatar": "https://cdn.example.com/avatar.jpg"
    }
  }
}
```

#### 4.4.2 刷新 Token
```http
POST /auth/refresh
```

**请求体:**
```json
{
  "refreshToken": "yyy"
}
```

**响应:**
```json
{
  "success": true,
  "data": {
    "accessToken": "new_xxx",
    "refreshToken": "new_yyy"
  }
}
```

---

## 5. 数据库设计

### 5.1 PostgreSQL 数据表设计

#### 5.1.1 用户表 (users)
```sql
CREATE TABLE users (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  wechat_openid VARCHAR(100) UNIQUE,
  douyin_openid VARCHAR(100) UNIQUE,
  nickname VARCHAR(100) NOT NULL,
  avatar_url VARCHAR(500),
  email VARCHAR(100) UNIQUE,
  phone VARCHAR(20) UNIQUE,
  membership_level VARCHAR(20) DEFAULT 'free',
  membership_expires_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_wechat_openid ON users(wechat_openid);
CREATE INDEX idx_users_douyin_openid ON users(douyin_openid);
CREATE INDEX idx_users_membership ON users(membership_level, membership_expires_at);
```

#### 5.1.2 文章表 (articles)
```sql
CREATE TABLE articles (
  id VARCHAR(50) PRIMARY KEY,
  user_id VARCHAR(36) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(500) NOT NULL DEFAULT '',
  content JSONB,
  cover_image VARCHAR(500),
  tags VARCHAR(100)[] DEFAULT '{}',
  is_pinned BOOLEAN DEFAULT FALSE,
  pinned_at TIMESTAMP,
  is_deleted BOOLEAN DEFAULT FALSE,
  deleted_at TIMESTAMP,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP,
  font_family VARCHAR(50),
  font_size DECIMAL(5,2),
  font_weight INTEGER CHECK (font_weight BETWEEN 0 AND 9),
  line_height DECIMAL(5,2),
  letter_spacing DECIMAL(5,2),
  has_update BOOLEAN DEFAULT FALSE
);

CREATE INDEX idx_articles_user_id ON articles(user_id);
CREATE INDEX idx_articles_created_at ON articles(created_at DESC);
CREATE INDEX idx_articles_updated_at ON articles(updated_at DESC);
CREATE INDEX idx_articles_is_pinned ON articles(is_pinned, pinned_at DESC);
CREATE INDEX idx_articles_is_deleted ON articles(is_deleted);
CREATE INDEX idx_articles_tags ON articles USING GIN(tags);
CREATE INDEX idx_articles_content ON articles USING GIN(content);

-- 全文搜索索引
CREATE INDEX idx_articles_fulltext ON articles
  USING GIN(to_tsvector('chinese', coalesce(title, '') || ' ' || coalesce(content::text, '')));
```

**字段说明:**
- `id`: 使用时间戳字符串 (与前端一致)
- `content`: 使用 JSONB 存储Quill Delta格式
- `tags`: 数组类型,支持多标签
- `has_update`: 同步标记,标识是否有未同步到本地的更新

#### 5.1.3 活动数据表 (activities)
```sql
CREATE TABLE activities (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR(36) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  count INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(user_id, date)
);

CREATE INDEX idx_activities_user_date ON activities(user_id, date DESC);
```

#### 5.1.4 AI 建议缓存表 (ai_suggestions)
```sql
CREATE TABLE ai_suggestions (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR(36) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  article_id VARCHAR(50) REFERENCES articles(id) ON DELETE CASCADE,
  original_text TEXT NOT NULL,
  suggestion_text TEXT NOT NULL,
  type VARCHAR(20) NOT NULL,
  tokens_used INTEGER,
  model VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP
);

CREATE INDEX idx_ai_suggestions_user_article ON ai_suggestions(user_id, article_id);
CREATE INDEX idx_ai_suggestions_original_text ON ai_suggestions USING hash(original_text);
CREATE INDEX idx_ai_suggestions_expires_at ON ai_suggestions(expires_at);
```

#### 5.1.5 同步记录表 (sync_logs)
```sql
CREATE TABLE sync_logs (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR(36) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  action VARCHAR(20) NOT NULL,
  resource_type VARCHAR(20) NOT NULL,
  resource_id VARCHAR(50) NOT NULL,
  status VARCHAR(20) NOT NULL,
  error_message TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sync_logs_user_id ON sync_logs(user_id, created_at DESC);
CREATE INDEX idx_sync_logs_resource ON sync_logs(resource_type, resource_id);
```

### 5.2 Redis 数据结构设计

#### 5.2.1 热点文章缓存
```
Key: article:detail:{articleId}
Type: Hash
TTL: 3600 (1小时)
Fields:
  - id: "1704067200000"
  - title: "文章标题"
  - content: "[{\"insert\":\"内容\\n\"}]"
  - coverImage: "https://..."
  - tags: ["tag1", "tag2"]
  - ...
```

#### 5.2.2 用户会话
```
Key: session:{userId}
Type: Hash
TTL: 86400 (24小时)
Fields:
  - accessToken: "xxx"
  - refreshToken: "yyy"
  - expiresIn: 7200
```

#### 5.2.3 文章列表缓存
```
Key: article:list:{userId}:{page}:{pageSize}
Type: String (JSON)
TTL: 300 (5分钟)
Value: [{"id":"...","title":"...",...},...]
```

#### 5.2.4 AI 建议缓存
```
Key: ai:suggestion:{hash(original_text)}
Type: Hash
TTL: 604800 (7天)
Fields:
  - originalText: "原文"
  - suggestionText: "建议内容"
  - type: "expand"
  - createdAt: "2024-01-01T00:00:00.000Z"
```

---

## 6. 后端实现方案

### 6.1 项目结构 (NestJS 示例)

```
src/
├── main.ts                          # 应用入口
├── app.module.ts                    # 根模块
├── config/                          # 配置文件
│   ├── database.config.ts
│   ├── redis.config.ts
│   └── ai.config.ts
├── common/                          # 通用模块
│   ├── filters/                     # 异常过滤器
│   ├── interceptors/                # 拦截器(日志、缓存)
│   ├── guards/                      # 守卫(认证、权限)
│   ├── decorators/                  # 装饰器
│   └── dto/                         # 通用 DTO
├── modules/
│   ├── auth/                        # 认证模块
│   │   ├── auth.module.ts
│   │   ├── auth.controller.ts
│   │   ├── auth.service.ts
│   │   └── dto/
│   ├── users/                       # 用户模块
│   │   ├── users.module.ts
│   │   ├── users.controller.ts
│   │   ├── users.service.ts
│   │   ├── users.repository.ts
│   │   └── dto/
│   ├── articles/                    # 文章模块
│   │   ├── articles.module.ts
│   │   ├── articles.controller.ts
│   │   ├── articles.service.ts
│   │   ├── articles.repository.ts
│   │   └── dto/
│   ├── ai/                          # AI 模块
│   │   ├── ai.module.ts
│   │   ├── ai.controller.ts
│   │   ├── ai.service.ts
│   │   └── dto/
│   ├── activity/                    # 活动数据模块
│   │   ├── activity.module.ts
│   │   ├── activity.controller.ts
│   │   ├── activity.service.ts
│   │   └── dto/
│   ├── storage/                     # 存储模块
│   │   ├── storage.module.ts
│   │   ├── storage.service.ts
│   │   └── providers/
│   │       ├── local.provider.ts
│   │       ├── oss.provider.ts
│   │       └── s3.provider.ts
│   └── membership/                  # 会员模块
│       ├── membership.module.ts
│       ├── membership.controller.ts
│       ├── membership.service.ts
│       └── dto/
└── database/                        # 数据库相关
    ├── migrations/                  # 迁移文件
    └── seeds/                      # 种子数据
```

### 6.2 核心代码示例

#### 6.2.1 Articles Service
```typescript
// src/modules/articles/articles.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Article } from './article.entity';
import { CreateArticleDto } from './dto/create-article.dto';
import { UpdateArticleDto } from './dto/update-article.dto';
import { CacheService } from '../cache/cache.service';

@Injectable()
export class ArticlesService {
  constructor(
    @InjectRepository(Article)
    private articleRepository: Repository<Article>,
    private cacheService: CacheService,
  ) {}

  async findAll(userId: string, query: any): Promise<{ articles: Article[]; total: number }> {
    const { page = 1, pageSize = 20, tags, keyword, sortBy, sortOrder } = query;

    const queryBuilder = this.articleRepository
      .createQueryBuilder('article')
      .where('article.userId = :userId', { userId })
      .andWhere('article.isDeleted = :isDeleted', { isDeleted: false });

    // 标签过滤
    if (tags && tags.length > 0) {
      queryBuilder.andWhere('article.tags && :tags', { tags });
    }

    // 关键词搜索
    if (keyword) {
      queryBuilder.andWhere(
        '(article.title ILIKE :keyword OR article.content::text ILIKE :keyword)',
        { keyword: `%${keyword}%` }
      );
    }

    // 排序
    const sortField = sortBy === 'pinnedAt' ? 'pinnedAt' : 'createdAt';
    queryBuilder.orderBy(`article.${sortField}`, sortOrder === 'asc' ? 'ASC' : 'DESC');

    // 分页
    queryBuilder.skip((page - 1) * pageSize).take(pageSize);

    const [articles, total] = await queryBuilder.getManyAndCount();

    return { articles, total };
  }

  async findOne(userId: string, articleId: string): Promise<Article> {
    // 先查缓存
    const cached = await this.cacheService.get(`article:detail:${articleId}`);
    if (cached) {
      return JSON.parse(cached);
    }

    // 查数据库
    const article = await this.articleRepository.findOne({
      where: { id: articleId, userId, isDeleted: false },
    });

    if (!article) {
      throw new NotFoundException('文章不存在');
    }

    // 写缓存
    await this.cacheService.set(`article:detail:${articleId}`, JSON.stringify(article), 3600);

    return article;
  }

  async create(userId: string, createDto: CreateArticleDto): Promise<Article> {
    const article = this.articleRepository.create({
      ...createDto,
      userId,
      id: Date.now().toString(),  // 使用时间戳作为 ID
      createdAt: new Date(),
    });

    const saved = await this.articleRepository.save(article);

    // 清除列表缓存
    await this.cacheService.deletePattern(`article:list:${userId}:*`);

    return saved;
  }

  async update(userId: string, articleId: string, updateDto: UpdateArticleDto): Promise<Article> {
    const article = await this.findOne(userId, articleId);

    Object.assign(article, updateDto, { updatedAt: new Date() });

    const updated = await this.articleRepository.save(article);

    // 清除缓存
    await this.cacheService.delete(`article:detail:${articleId}`);
    await this.cacheService.deletePattern(`article:list:${userId}:*`);

    return updated;
  }

  async delete(userId: string, articleId: string): Promise<void> {
    const article = await this.findOne(userId, articleId);

    article.isDeleted = true;
    article.deletedAt = new Date();

    await this.articleRepository.save(article);

    // 清除缓存
    await this.cacheService.delete(`article:detail:${articleId}`);
    await this.cacheService.deletePattern(`article:list:${userId}:*`);
  }

  async togglePin(userId: string, articleId: string, isPinned: boolean): Promise<Article> {
    const article = await this.findOne(userId, articleId);

    article.isPinned = isPinned;
    article.pinnedAt = isPinned ? new Date() : null;

    const updated = await this.articleRepository.save(article);

    // 清除缓存
    await this.cacheService.delete(`article:detail:${articleId}`);
    await this.cacheService.deletePattern(`article:list:${userId}:*`);

    return updated;
  }
}
```

#### 6.2.2 AI Service
```typescript
// src/modules/ai/ai.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { CacheService } from '../cache/cache.service';
import * as crypto from 'crypto';

@Injectable()
export class AIService {
  private readonly openaiApiKey: string;
  private readonly apiUrl: string;

  constructor(
    private configService: ConfigService,
    private cacheService: CacheService,
  ) {
    this.openaiApiKey = this.configService.get('OPENAI_API_KEY');
    this.apiUrl = this.configService.get('OPENAI_API_URL', 'https://api.openai.com/v1');
  }

  async generateSuggestion(
    type: 'expand' | 'polish' | 'summarize',
    content: string,
    context?: string,
  ): Promise<AsyncIterable<{ token: string } | { done: true; fullText: string }>> {
    // 检查缓存
    const cacheKey = `ai:suggestion:${crypto.hash('md5', content as any)}`;
    const cached = await this.cacheService.get(cacheKey);

    if (cached) {
      // 返回缓存的建议
      return this.streamText(cached);
    }

    // 生成提示词
    const prompt = this.buildPrompt(type, content, context);

    // 调用 OpenAI API (流式)
    const response = await fetch(`${this.apiUrl}/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.openaiApiKey}`,
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [{ role: 'user', content: prompt }],
        stream: true,
      }),
    });

    // 收集完整响应
    let fullText = '';

    // 返回流式响应
    return this.streamOpenAIResponse(response, async (text) => {
      fullText = text;
      // 缓存结果
      await this.cacheService.set(cacheKey, text, 604800); // 7天
    });
  }

  private buildPrompt(type: string, content: string, context?: string): string {
    const prompts = {
      expand: `请扩写以下文本,使其更加丰富和详细:\n\n${content}`,
      polish: `请润色以下文本,使其更加通顺和专业:\n\n${content}`,
      summarize: `请总结以下文本的核心内容:\n\n${content}`,
    };

    return context ? `${prompts[type]}\n\n上下文:\n${context}` : prompts[type];
  }

  private async *streamOpenAIResponse(
    response: Response,
    onComplete: (text: string) => Promise<void>,
  ): AsyncIterable<{ token: string } | { done: true; fullText: string }> {
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let fullText = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') {
            await onComplete(fullText);
            yield { done: true, fullText };
            return;
          }

          try {
            const parsed = JSON.parse(data);
            const token = parsed.choices[0]?.delta?.content;
            if (token) {
              fullText += token;
              yield { token };
            }
          } catch (e) {
            // 忽略解析错误
          }
        }
      }
    }
  }

  private async *streamText(text: string): AsyncIterable<{ token: string } | { done: true; fullText: string }> {
    const chars = text.split('');
    let current = '';

    for (const char of chars) {
      current += char;
      yield { token: char };
      // 模拟打字延迟
      await new Promise(resolve => setTimeout(resolve, 20));
    }

    yield { done: true, fullText: current };
  }
}
```

### 6.3 部署架构

```
┌─────────────────────────────────────────────────────────────┐
│                       Nginx (反向代理)                       │
│                  (SSL 终止 + 负载均衡)                      │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                   PM2 / Docker Swarm                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  Node.js     │  │  Node.js     │  │  Node.js     │       │
│  │  Instance 1  │  │  Instance 2  │  │  Instance 3  │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              PostgreSQL (主从复制) + Redis Cluster          │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                 对象存储 (OSS) + CDN                        │
└─────────────────────────────────────────────────────────────┘
```

---

## 7. 接入流程设计

### 7.1 前端接入步骤

#### Step 1: 创建 API Service 实现
```dart
// lib/data/services/api/real_api_service.dart
import 'package:http/http.dart' as http;
import 'dart:convert';

class RealApiService implements ApiService {
  final String baseUrl = 'https://api.yanyiheyi.com/api/v1';
  String? _accessToken;

  @override
  Future<NetworkResult<List<Article>>> getArticles({
    required int page,
    required int pageSize,
    List<String>? tags,
  }) async {
    try {
      final queryParams = {
        'page': page.toString(),
        'pageSize': pageSize.toString(),
        if (tags != null) 'tags': tags.join(','),
      };

      final uri = Uri.parse('$baseUrl/articles').replace(queryParameters: queryParams);
      final response = await http.get(
        uri,
        headers: {
          'Authorization': 'Bearer $_accessToken',
          'Content-Type': 'application/json',
        },
      );

      if (response.statusCode == 200) {
        final json = jsonDecode(response.body);
        final articles = (json['data']['articles'] as List)
            .map((item) => Article.fromJson(item))
            .toList();
        return Success(articles);
      } else {
        return Failure(AppErrorFactory.fromStatusCode(response.statusCode));
      }
    } catch (e) {
      return Failure(AppErrorFactory.fromException(e));
    }
  }

  // 实现其他方法...
}
```

#### Step 2: 更新 main.dart
```dart
// lib/main.dart
void main() async {
  // ...

  // 创建 API 服务
  final apiService = ApiServiceFactory.getInstance();

  // 如果使用真实 API,替换为 RealApiService
  // ApiServiceFactory.setService(RealApiService());

  runApp(MyApp());
}
```

#### Step 3: 测试 API 调用
```dart
// 在 ActivityProvider 中测试
Future<void> _initializeData() async {
  // ...

  // 从远程服务器获取数据
  final remoteResult = await _articleRepository.getArticles(
    page: 1,
    pageSize: 1000,
  );

  if (remoteResult.isSuccess) {
    appLogger.info('✅ API 调用成功');
  } else {
    appLogger.error('❌ API 调用失败: ${remoteResult.error}');
  }
}
```

### 7.2 后端开发步骤

#### Phase 1: 基础设施搭建 (1周)
1. 搭建 NestJS 项目
2. 配置 PostgreSQL + Redis
3. 配置 TypeORM
4. 实现认证中间件 (JWT)
5. 配置文件上传 (OSS)

#### Phase 2: 文章模块开发 (2周)
1. 创建 articles 数据表
2. 实现 Articles CRUD API
3. 实现批量操作 API
4. 实现搜索功能
5. 实现活动数据 API
6. 单元测试 + 集成测试

#### Phase 3: AI 模块开发 (1周)
1. 接入 OpenAI API
2. 实现流式响应
3. 实现缓存机制
4. 实现建议生成逻辑

#### Phase 4: 其他模块 (1周)
1. 用户模块
2. 认证模块 (微信/抖音登录)
3. 会员模块
4. 同步模块

#### Phase 5: 部署上线 (1周)
1. Docker 容器化
2. 配置 Nginx
3. 配置 SSL 证书
4. 配置 CDN
5. 性能测试 + 压力测试
6. 灰度发布

---

## 8. 安全性设计

### 8.1 认证与授权
- **JWT Token**: Access Token (2小时) + Refresh Token (30天)
- **Token 刷新**: 自动刷新机制
- **权限控制**: RBAC (Role-Based Access Control)
  - 普通用户: 只能操作自己的文章
  - VIP 用户: 额外权益

### 8.2 数据验证
- **输入验证**: class-validator (NestJS)
- **SQL 注入防护**: TypeORM 参数化查询
- **XSS 防护**: Quill Delta 已自带转义

### 8.3 限流与防护
- **Rate Limiting**: 基于 IP + 用户 ID 的限流
  - 文章列表: 100 次/分钟
  - 文章详情: 200 次/分钟
  - AI 建议: 20 次/分钟 (VIP 用户 60 次/分钟)
- **防刷机制**: Redis 计数器

### 8.4 数据加密
- **HTTPS**: 强制使用 TLS 1.3
- **敏感数据**: 数据库加密存储 (可选)
- **图片上传**: 验证文件类型 + 病毒扫描

---

## 9. 性能优化

### 9.1 数据库优化
- **索引**: 已在表设计中定义
- **查询优化**: 避免 N+1 查询,使用 JOIN
- **读写分离**: 主从复制,读操作走从库
- **连接池**: 配置合理的连接池大小

### 9.2 缓存策略
- **热点数据**: Redis 缓存 (1-24小时)
- **列表数据**: Redis 缓存 (5分钟)
- **AI 建议**: Redis 缓存 (7天)
- **缓存更新**: 写时删除 (Write-Through)

### 9.3 CDN 加速
- **静态资源**: 图片、封面图、头像
- **API 响应**: 启用 Gzip 压缩
- **地理位置**: 多地域部署

### 9.4 代码优化
- **批量操作**: 减少 API 调用次数
- **分页加载**: 避免一次性加载大量数据
- **异步处理**: 使用消息队列处理耗时操作 (如 AI 生成)

---

## 10. 监控与日志

### 10.1 日志系统
- **应用日志**: Winston / Pino
- **日志级别**: ERROR, WARN, INFO, DEBUG
- **日志存储**: Elasticsearch + Kibana (ELK Stack)
- **敏感信息脱敏**: Token、密码等

### 10.2 性能监控
- **APM 工具**: New Relic / DataDog / 阿里云 ARMS
- **关键指标**:
  - API 响应时间
  - 数据库查询时间
  - 缓存命中率
  - 错误率

### 10.3 告警机制
- **错误告警**: Sentry (错误追踪)
- **性能告警**: 响应时间 > 1s 触发告警
- **可用性告警**: 服务不可用立即告警

---

## 11. 总结与建议

### 11.1 架构优势
1. **分层清晰**: Controller → Service → Repository
2. **职责分离**: 每个模块独立,易于维护
3. **可扩展性**: 支持水平扩展
4. **缓存策略**: 多级缓存,提升性能

### 11.2 待完善功能
1. **实时同步**: WebSocket 推送更新
2. **版本控制**: 文章历史版本管理
3. **协作编辑**: 多人实时编辑 (类似 Google Docs)
4. **全文搜索**: Elasticsearch 集成
5. **数据分析**: 用户行为分析、AI 使用统计

### 11.3 开发优先级
1. **Phase 1 (MVP)**:
   - 用户认证 (微信登录)
   - 文章 CRUD
   - 基础 AI 建议
   - 本地 + 远程同步

2. **Phase 2**:
   - 会员系统
   - 高级 AI 功能 (润色、摘要)
   - 封面图上传
   - 搜索功能

3. **Phase 3**:
   - 实时同步
   - 协作编辑
   - 数据统计
   - 性能优化

### 11.4 技术债务
1. **同步冲突**: 当前以远程为准,未来需实现冲突检测
2. **离线编辑**: 需实现队列机制,离线时缓存操作
3. **AI 成本**: 需实现配额管理、计费系统
4. **数据迁移**: 需实现版本化迁移脚本

---

## 附录

### A. 参考资料
- [NestJS 官方文档](https://docs.nestjs.com/)
- [TypeORM 文档](https://typeorm.io/)
- [Flutter Quill 文档](https://pub.dev/packages/flutter_quill)
- [OpenAI API 文档](https://platform.openai.com/docs/api-reference)
- [PostgreSQL JSONB 文档](https://www.postgresql.org/docs/current/datatype-json.html)

### B. 数据库迁移脚本示例
```sql
-- V1__init_schema.sql
-- 创建初始表结构

-- ... (上面的 CREATE TABLE 语句)

-- 插入测试数据
INSERT INTO users (id, nickname, membership_level) VALUES
  ('test-user-1', '测试用户', 'free');

INSERT INTO articles (id, user_id, title, content, created_at) VALUES
  ('1704067200000', 'test-user-1', '我的第一篇文章', '[{"insert":"Hello, World!\n"}]', NOW());
```

### C. Docker Compose 示例
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: yanyiheyi
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data

  backend:
    build: .
    ports:
      - "3000:3000"
    environment:
      DATABASE_HOST: postgres
      REDIS_HOST: redis
    depends_on:
      - postgres
      - redis

volumes:
  postgres-data:
  redis-data:
```

---

**文档版本**: v1.0
**最后更新**: 2025-01-05
**作者**: Claude (Sonnet 4.5)
